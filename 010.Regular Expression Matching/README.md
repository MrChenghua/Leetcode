这个问题纠结了很久，一开始用遍历p，生成新list和s对比的方法。结果发现有很多特殊的实例无法通过。于是就在网上找了找思路，写了一个递归。

进入Function isMatch，

首先判断p是不是为空：如果是并且s为空则输出True，否则为False。

如果p的长度为1，或者p[1]!='*'：如果s不为空，并且(p[0]!=s[0] or p[0]!='.')，那么输出False。否则返回 isMatch(s[1:],p[1:])。

剩余情况(len(p>1) 并且 p[1]=='*'): 如果s不为空，并且(p[0]==s[0] or p[0]=='.')，判断 isMatch(s,p[2:])，如果是True则返回True。

之后 s=s[1:]，直至len(s)=0或者发现(p[0]!=s[0] 并且 p[0]!='.')。跳出循环，返回 isMatch(s,p[2:])

|p的长度|判别条件|输出结果|步骤
|-|-|-|-|
| len(p)==0     | len(s)==0| True |1|
| | len(s)!=0| False ||
| len(p)==1     | len(s) > 0 and (p[0]!=s[0] or p[0]!='.')| False |2|
| | 否则 | 返回 isMatch(s[1:],p[1:]) ||
| len(p) > 1    | p[1]!='\*', s非空，且(p[0]==s[0] or p[0]=='.')| 返回 isMatch(s[1:],p[1:]) |3|
| |p[1]=='\*',s非空，且(p[0]==s[0] or p[0]=='.')| 判断 isMatch(s,p[2:]) 是否为True（旨在判断字符串p，在'\*'之后是否还有和'\*'前相同的字符）, s = s[1:]，循环该步骤。|4|
| |否则|返回 isMatch(s,p[2:])||
| |p[1]=='\*'|返回 isMatch(s,p[2:])|5|

可将步骤3，与2合并。
